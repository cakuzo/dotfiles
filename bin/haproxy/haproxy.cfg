global
  log 127.0.0.1 local0
  user haproxy
  group haproxy
  daemon
  # debug
  # quiet
  maxconn 10000
  pidfile /var/run/haproxy.pid
# ~~~ SSL global defaults ~~~
  ca-base <ceritifatedirectorypath>
  crt-base <certificateCAdirectorypath>
  ssl-server-verify required
  # prefer-server-ciphers # default since v1.5-dev12
  tune.ssl.default-dh-param 2048 # <1024 leads to a warning

# ~~~ Unix Stat Socket ~~~
  stats socket /var/run/haproxy.sock mode 600 level admin
  # stats socket ipv4@127.0.0.1:51415 level admin
# ~~~ Example Socket Commands ~~~
  # echo "show stat" | socat stdio /var/run/haproxy.sock
  # echo "show info" | socat stdio /var/run/haproxy.sock
  # echo "show errors" | socat stdio /var/run/haproxy.sock

# ~~~ haproxy documentation and more ~~~
  # http://cbonte.github.io/haproxy-dconv/configuration-1.5.html
  # https://wiki.mozilla.org/Security/Server_Side_TLS
  # https://jve.linuxwall.info/ressources/taf/haproxy-aws/#url-filtering-with-acls
  # https://kura.io/2014/07/02/haproxy-ocsp-stapling/

defaults
  log global
  mode http
  option httplog clf
  option dontlognull
  option splice-auto
  option http-server-close
  option http-pretend-keepalive
  retries 1
  timeout http-request    10s #slowloris protection
  timeout queue           1m
  timeout connect         10s
  timeout client          5m
  timeout server          5m
  timeout http-keep-alive 5s
  timeout check           10s

# ~~~ chrome 408 errors workaround ~~~
  errorfile 408 /dev/null

# ~~~ nice errorfile with bears ~~~
#  errorloc303 400 <url>
#  errorloc303 403 <url>
#  errorloc303 500 <url>
#  errorloc303 502 <url>
#  errorloc303 503 <url>

userlist stats-auth
  group  admin     users              <adminusername>
  user   tldadmin  insecure-password  <adminuserpassword>
  group  readonly  users              haproxy
  user   haproxy   insecure-password  haproxy

listen stats :1936
  acl whitelist src -f <ipwhitelistfile>
  acl AUTH http_auth(stats-auth)
  acl AUTH_ADMIN http_auth_group(stats-auth) admin
#  stats admin if AUTH_ADMIN whitelist
#  stats realm Haproxy\ Statistics
  stats enable
  stats scope main
  stats hide-version
  stats http-request auth unless AUTH whitelist
  stats admin if AUTH_ADMIN whitelist
  stats scope backend1
  stats uri /haproxy_stats
# ~~~ Statistics Report URL ~~~
  # http://<yourdomain>:1936/haproxy_stats

frontend main
  bind *:80
  bind *:443 ssl crt <yourdomain>.pem ecdhe prime256v1 ciphers AESGCM:AES:+EECDH:+EDH:+RSA:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS:!EECDH+RC4:!RC4 no-sslv3

# ~~~ <yourdomain> specific ACLs ~~~
  acl url_appserver path_beg /appserver /development
  acl url_common path_beg /common
  # workaround for the /v1.014.a/common requests
  acl url_vcommon path_reg ^/[0-9a-z.]+/common.*$
  acl host_tldcom hdr_end(host) -i <yourdomain.com>

  acl url_vpublic path_reg ^/[0-9a-z.]+/public.*$
  acl url_vmembers path_reg ^/[0-9a-z.]+/member.*$

# ~~ Other ACLs ~~~
  acl whitelist src -f /etc/haproxy/whitelist.lst
  acl https ssl_fc
  acl secured_cookie res.hdr(Set-Cookie),lower -m sub secure

# ~~~ detect hackers ~~~
  acl w00tw00t path_beg /w00tw00t
  acl wpreadme path_end readme.html or readme.txt

# ~~~ DDoS protection ~~~
  # enable tracking of counters for src ip in the default stick-table
  # hint: this is currently not activated
  tcp-request content track-sc0 src
  # Whitelist: Allow IPs to bypass the filters
  http-request add-header X-Haproxy-ACL %[req.fhdr(X-Haproxy-ACL,-1)]whitelisted, if { src -f /etc/haproxy/whitelist.lst }
  http-request allow if { src -f /etc/haproxy/whitelist.lst }
  # Stick Table Definitions
  # - conn_cur: count active connections
  # - conn_rate(10s): average incoming connection rate over 10 seconds
  # - http_req_rate(10s): Monitors the number of request sent by an IP over a period of 10 seconds
  # - http_err_rate(10s): Monitors the number of errors generated by an IP over a period of 10 seconds
  stick-table type ip size 500k expire 30s store conn_cur,conn_rate(10s),http_req_rate(10s),http_err_rate(10s)
  # Reject the new connection if the client already has 100 opened
  http-request add-header X-Haproxy-ACL %[req.fhdr(X-Haproxy-ACL,-1)]over-100-active-connections, if { src_conn_cur ge 100 }
  # Reject the new connection if the client has opened more than 100 connections in 10 seconds
  http-request add-header X-Haproxy-ACL %[req.fhdr(X-Haproxy-ACL,-1)]over-100-connections-in-10-seconds, if { src_conn_rate ge 100 }
  # Reject the connection if the client has passed the HTTP error rate
  http-request add-header X-Haproxy-ACL %[req.fhdr(X-Haproxy-ACL,-1)]high-error-rate, if { sc0_http_err_rate() gt 100 }
  # Reject the connection if the client has passed the HTTP request rate
  http-request add-header X-Haproxy-ACL %[req.fhdr(X-Haproxy-ACL,-1)]high-request-rate, if { sc0_http_req_rate() gt 500 }

  # if previous ACL didn't pass and aren't whitelisted
  acl whitelisted req.fhdr(X-Haproxy-ACL) -m beg whitelisted,
  acl fail-validation req.fhdr(X-Haproxy-ACL) -m found
  # uncomment following line to activate 
  #http-request deny if !whitelisted fail-validation
  http-request deny if w00tw00t

# ~~~ Wordpress basic security ~~~
  http-request deny if wpreadme

# ~~~ Set X-SSL Header if ssl ~~~
  http-request set-header X-SSL %[ssl_fc]

# ~~~ HTTP Header Security ~~~
  rspidel ^Server:.*$
  rspidel ^X-Powered-By:.*$
  #rspidel ^X-Pingback:.*$
  rspadd X-XSS-Protection:\ 1;\ mode=block
  rspadd X-Content-Type-Options:\ nosniff 

# ~~~ Cookie Security ~~~
###  rspirep ^(set-cookie:.*) \1;\ Secure if https !secured_cookie
###  rspirep ^Set-Cookie:\ (PHPSESSID.*)    Set-Cookie:\ \1;\ HttpOnly

# ~~~ Bash Shellshock vulnerability (CVE-2014-6271 and CVE-2014-7169) ~~~
  reqdeny ^[^:]+:\s*\(\s*\)\s+\{
  reqdeny ^[^:]+:\s+.*?(<<[^<;]+){5,}

# ~~~ Cloudflare Real IP Forward for <yourotherdomain.de> ~~~
  acl host_tldde hdr_end(host) -i <yourotherdomain.de>
  acl FROM_CLOUDFLARE src -f /etc/haproxy/cloudflare_ips.lst
  reqidel ^X-Forwarded-For:.* if ! LOCALHOST
  reqirep ^CF-Connecting-IP:(.*)$ X-Forwarded-For:\1 if FROM_CLOUDFLARE host_tldde
  option forwardfor if-none

# ~~~ Forwarded Protocol Headers ~~~
  reqadd X-Forwarded-Proto:\ https if { ssl_fc }
  reqadd X-Forwarded-Proto:\ http if !{ ssl_fc }

# ~~~ Log more details for Debugging ~~~
  capture request  header Host len 256
  capture request  header Content-Length len 256
  capture request  header Referer len 256
  capture request  header X-Haproxy-ACL len 256
  capture response header X-Haproxy-ACL len 256
  capture response header Server len 20
  capture response header Content-Length len 10
  capture response header Cache-Control len 8
  capture response header Via len 20
  capture response header Location len 20

# ~~~ <yourdomain> specific BackendRouting ~~~
  # dev-versions accessible only internally
  use_backend backend1 if url_vpublic whitelist
  use_backend backend2 if url_vmembers whitelist

  # live version 
  use_backend backend1 if url_appserver host_tldcom
  use_backend backend2 if url_member host_tldcom
  use_backend backend3 if url_common host_tldcom
  use_backend backend3 if url_vcommon host_tldcom
  default_backend backend4

backend backend1
  balance roundrobin
  # redirect scheme https if !{ ssl_fc }
  # ssl forcing have to be compatible with application
  server hostname1 10.10.141.8:80
backend backend2
  balance roundrobin
  redirect scheme https if !{ ssl_fc }
  server hostname2 10.10.37.200:80 
backend backend3
  balance roundrobin
  server hostname3 10.10.37.200:80 
backend backend4
  balance roundrobin
  redirect scheme http if { ssl_fc }
  server hostname4 10.10.141.19:80
